#28. .NET Collections. Indexator. List. Dictionary. Queue. SortedList.


1.  Чем индексаторы похожи на свойства, и какова роль ключевого слова this в определении 
индексатора?
- Индексаторы похожи на свойства тем, что они оба предоставляют доступ к данным объекта. 
Ключевое слово this в определении индексатора указывает на текущий экземпляр класса и 
используется для доступа к элементам коллекции или массива по индексу.

2.  В каких сценариях вы бы выбрали List<T> вместо ArrayList, и почему List<T> работает 
лучше в большинстве случаев?
- List<T> предпочтительнее ArrayList в сценариях, где требуется работа с типизированными 
коллекциями. List<T> обеспечивает более безопасное и эффективное использование памяти 
за счет хранения только элементов указанного типа T.

3.  Каковы преимущества использования типа value для типа T в List<T> с точки зрения 
использования памяти?
- Преимущества использования типа value для типа T в List<T> включают экономию памяти, 
так как элементы хранятся непосредственно в списке, а не по ссылке как в случае 
ссылочных типов.

4.  Объясните важность уникальности ключей в Dictionary<TKey, TValue>.
- Уникальность ключей в Dictionary<TKey, TValue> важна для обеспечения правильной работы 
структуры данных. Ключи используются для доступа к значениям, и если ключи не уникальны, 
могут возникнуть конфликты и некорректное поведение словаря.

5.  Можно ли использовать нулевое значение для ключа или значения в Dictionary<TKey, TValue> 
и при каких условиях?
- В Dictionary<TKey, TValue> нельзя использовать нулевое значение для ключа, так 
как ключи не могут быть null. Однако, значение может быть null при условии, 
что тип значения TValue позволяет это.

6.  Какие три основные операции можно выполнить над очередью<T> и ее элементами?
- Три основные операции над очередью<T> включают добавление элемента в конец очереди 
(Enqueue), извлечение элемента из начала очереди (Dequeue) и просмотр элемента в 
начале очереди без его удаления (Peek).

7.  Когда лучше использовать ConcurrentQueue<T>, а не Queue<T>, и почему?
- ConcurrentQueue<T> предпочтительнее Queue<T> в сценариях, где требуется многопоточный 
доступ к очереди. ConcurrentQueue<T> обеспечивает безопасное добавление и удаление 
элементов из разных потоков без необходимости использования дополнительных механизмов 
синхронизации.

8.  Как внутренне хранятся элементы отсортированного списка и каково значение 
свойства capacity?
- Элементы отсортированного списка внутренне хранятся в упорядоченном виде, обеспечивая 
быстрый поиск элементов по значению. Свойство capacity указывает текущую ёмкость списка, 
то есть максимальное количество элементов, которое может содержать список без повторного 
выделения памяти.

9.  Почему операции над отсортированным списком могут выполняться медленнее, чем 
над Hashtable, и какую гибкость он обеспечивает взамен?
- Операции над отсортированным списком могут выполняться медленнее, чем над Hashtable, 
из-за необходимости поддержания порядка элементов. Однако отсортированный список 
обеспечивает гибкость в виде поддержки упорядоченного доступа к элементам и возможности 
выполнения операций поиска и вставки с временной сложностью O(log n).